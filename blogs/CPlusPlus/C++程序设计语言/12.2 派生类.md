# 12.2 派生类

```c++
#include <iostream>

class Employee{
    int age;
public:
    Employee() { }
};


class Manager:public Employee{
    int cnt;
public:
    Manager(Employee e,int cnt):Employee(e),cnt(cnt) { }
};

int main(){
    Manager M(Employee(),10);
    Employee E();
    Employee *p = &M;			//正确，基类的指针可以指向子类成员
    Manager* *p2 = &E;			//错误，但是子类的指针不能指向基类成员
    Manager* p2 = static_cast<Manager*>(&M);//正确，蛮力强转
    return 0;
}
```

### 12.2.1 成员函数

在类的继承时，如果基类和子类有一个完全相同的函数，调用子类函数的时候，会**覆盖**基类的函数，进而导致基类的函数无法访问

因此前往别写这样的代码

```c++
class A{
public:
    void print();
};
class B{
public:
	void print();  
};
void B::print(){
	print();//如果这样写，调用的就是自己（无限递归）	
}
```

### 12.2.2 构造函数和析构函数

```c++
class A{
    int a,b;
public:
    A(int a,int b):a(a),b(b) { }	//基类的构造函数不是默认构造函数
    void print();
};
class B{
    int c;
public:
    B(int a,b,c):A(a,b),c(c) { }	//那么子类必须要给基类的构造函数传参初始化
	void print();  
};
```

### 12.2.3 复制

![image-20211118090618392](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211118090618392.png)

其实就是把子类中包含父类的部分给父类复制。

### 12.2.4 类层次结构

![image-20211118090802057](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211118090802057.png)

### 12.2.5 类型域

引入类型域的问题在于：
<font color="red">给定一个类型为Base*的指针，被指向的对象是属于哪个类型呢？</font>

```c++
struct Employee{
public:
	enum Empl_type { M, E};	//类型域
    Empl_type type;
    Employee() : type(E) { }
private:
    string first_name,family_name;
    ···
};

struct Manager : public Employee{
	list<Employee *> group;	//Manager手里管理的职员
public:
	Manager() {type = M; }
};

void print_employee(const Employee* e){
    switch(e->type){
        case Employee: E:	//如果类型域为E
            ···
            break;
        case Employee : M:	//如果类型域为M
            ···
            break;
    }
}
```

以上的代码展示了**类型域**的使用。即，可以通过为类标志一个域，以此判断这个类的身份。

但是这样会带来很多问题：

>1. 没有实现类的分离。对类的访问需要知道基类的知识，使得基类和派生类纠缠不清。
>2. 代码维护困难。添加和修改类的时候，需要考虑很多别的类的情况，与1有相似之处。

所以就引入了虚函数这一概念

### 12.2.5 虚函数

虚函数与类型域一样，也是为了解决这个问题：

<font color="red">给定一个类型为Base*的指针，被指向的对象是属于哪个类型呢？</font>

类型域不能为**编译器和装载程序提供函数之间正确的对应关系**，但是虚函数可以。

什么叫做提供正确的对应关系？

>有两个类，A类是B类的基类
>
>现在有一个A类指针，但是传入的参数是B\*。换句话说，我现在想要传入一个B\*，调用B的函数，但是原来的指针都是基类A的指针，那编译器怎么确定你是要调用的是B的函数，还是A的函数呢？

下面有一段代码

```c++
#include <iostream>
#include <string>
#include <list>
#include <algorithm>
using namespace std;
class Employee{
public:
    Employee(const string& name, int dept):name(name),dept(dept) { }
    virtual void print() const{
        cout << name << " " << endl;
    }
    string name;
    int dept;
};

class Manager : public Employee{
public:
	list<Employee *> group;	//Manager手里管理的职员
    short level;
    
	Manager(const string& name, int dept, int lvl):Employee(name,dept), level(lvl) { }		//由于Employee没有默认构造函数，所以需要传参
    void print() const{
        Employee::print();
        cout << "level:" << level << endl;
    }
};

void print_list(const list<Employee*>& s){
    //for_each在algorithm中
    //mem_fun(对象指针)和mem_fun_ref(对象实体)
    for_each(s.begin(),s.end(),mem_fun(&Employee::print));
}

int main(){
    Manager M("smith",1234,2);
    Employee E("tom",1234);
    list<Employee*> empl;
    empl.push_front(&E);
    empl.push_front(&M);
    print_list(empl);
    return 0;
}
```

上面代码调用了`prinf_list`函数，但是参数是一个`Employee*`构成的list，所以编译器怎么确定这个`Employee*`原来是`&Manager`还是`&Employee`呢？只需要在基类函数中加上`virtual`字段构成虚函数，书本上有一段对虚函数很好的解释。

![image-20211118105815910](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211118105815910.png)

如果没有这样一个界面，类型是什么就会调用什么。换句话说，如果没有`virtual`调用的都是`Employee*`的`print`函数。

