# 12.4 类层次结构设计

下面提供一种类的层次结构设计：

![image-20211120094012228](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120094012228.png)

#### 简要介绍：

![image-20211120094305129](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120094305129.png)

`BBwindow`是一个界面类，用来显示`Ival_box`、`Ival_slider`定义滑块的视觉形式和图形要素、`Ival_dial`通过旋转一个旋钮去调整某一个值、`Popup_ival_slider`显现一个固定位置的东西、`Flashing_ival_slider`用来做闪烁提示

#### 处理细节：

```c++
void interact(Ival_box* pb);	//函数用来进行交互

void fcn(){
    Ival_box* p2 = new Ival_dial(1,12);
	interact(p2);
}
```

为了使用一个类，我们定义一个指向基类的指针，交互通过传入指针交互（利用了虚函数的机制）

#### 问题：如何评价这个类的层次设计？

>优点：
>
>1. 在处理细节上利用了虚函数机制，如果这个类层次结构需要进行扩充，`fcn`函数是不需要变化的。
>
>缺点：
>
>1. `BBwindow`和`Ival_box`实际上并没有直接的关系，之所以需要将`BBwindow`作为基类，仅仅是因为`Ival_box`需要用到这个window界面。`Ival_box`还需要使用在别的界面，就会出现版本控制的问题。
>
>![image-20211120095852264](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120095852264.png)
>
>2. 如果`BBwindow`需要修改，那么所有的子类都需要修改。换句话说，基类对象大小的改变要求重新编译所有的派生类。

## 12.4.2 抽象类

因此我们要求重新设计类，满足

![image-20211120100251603](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120100251603.png)

因此，我们提供另外一种设计思路：

![image-20211120100921097](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120100921097.png)

在这个类层次结构中，`Ival_box`是一个抽象类，由纯虚函数构成，在`Ival_box`中没有数据，具体的数据在`Ival_slider`和`Ival_dial`中，`Ival_slider`保护继承`BBwindow`，这样做的好处是：

>1. 使用`Ival_slider`的程序员不应该知道底层的细节，因此他无法调用`BBwindow`
>2. `Ival_slider`的子类需要使用`BBwindow`，因此类内需要能使用`BBwindow`

**这样的设计已经分离了`BBwindow`和`Ival_slider`，而且做到了隐蔽的细节**，但是仍然没有解决版本控制的问题。

### 12.4.3 其他实现方式

为了实现版本控制的功能，我们可以将不同的版本与类层次结构中类组合：

![image-20211120102358161](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120102358161.png)

最终可以设计为这种形式：

![image-20211120102438756](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211120102438756.png)

#### 评价：

这样的设计非常灵活，不同的界面（window）组合成了一颗树，具体的界面的类变成了树的叶子结点。这样我们不需要关心界面的实现，也不需要修改interact类。

### 12.4.4 对象创建的局部化

上面的代码中，创建某一个界面的对象需要

````c++
class BBipop:public ipopup,protected BBsider;
````

这样的代码在管理上还存在一些问题，那么我们想：能不能使用一个管理类来管理版本的创建呢？

进而我们给出这样的代码：

```c++
class Ival_maker{
public:
	virtual Ival_dial* dial(int, int)=0;	//用作拨盘
    virtual Popup_ival_silder* popup_slider(int, int) = 0;//做滑块
};
//BB和LS的maker
class BB_maker:public Ival_maker{
public:
	Ival_dial* dial(int, int);
    Popup_ival_slider* popup_silder(int, int);
};
class LS_maker:public Ival_maker{
public:
	Ival_dial* dial(int, int);
    Popup_ival_slider* popup_silder(int, int);
};
//不同版本的拨盘
Ival_dial* dial(int a, int b){
    return new BB_ival_dial(a,b);	//new一个BB的版本的拨盘
}
Ival_dial* dial(int a,int b){
    return new LS_ival_dial(a,b);	//new一个LS版本的拨盘
}
//用户界面
//这个函数不需要知道用户的版本，直接创建拨盘
void user(Ival_maker* pim){
    Ival_box* pb = pim->dial(0,99);	//创建拨盘
    //···
}
//驱动程序
int driver(){
    BB_maker user1;
    LS_maker user2;
    //通过这种方式来使用不同的版本
    user(&user1);
    user(&user2);
    return 0;
}
```

