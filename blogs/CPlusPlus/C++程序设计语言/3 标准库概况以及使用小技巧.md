# 标准库

### Tip

#### 1.cin 是不能接受读入空格的。

```c++
cin >> str;
cout << str;
//如果输入:Hello world
//则会输入Hello
```

如果想要读一行，则需要使用`getline`函数。

```c++
getline(cin,str);
```

#### 2.vector的使用

vector是没有越界处理的，但是我们可以自己写一个`Vec` 继承vector 提供越界异常处理能力。

```c++
#include <iostream>
#include <vector>
using namespace std;
template<class T>class Vec:public vector<T>{
public:
    Vec():vector<T>(){}
    Vec(int s):vector<T>(s){}
    const T& operator[](int i)const { return this->at(i); } //at函数具有异常处理能力
    T& operator[](int i) { return this->at(i); }
    //之所以需要两个重载，是因为上面的重载是用于赋值（不能够修改）num1 = a[3];
    //，下面的是用于修改a[2] = 100;
};

int main(){
    Vec<int> a(100);
    a[100] = 0;
    return 0;
}   

```

#### 3.list的使用

使用list我们一般不去用下标运算（如：a[3]），而是使用迭代器来运算。

```c++
list<int> array;
void search(const int number){
    typedef list<int>::const_iterator L1;
    for(L1 i = array.begin();i != array.end();i ++){
        if(number == *i){
			cout << "find it";
            return;
        }
    }
}
```

要注意这个`const_iterator`指的并不是L1类型的`i`不能改变，而是指`i`所指向的那个对象的值不能改变。

#### 4.map的使用

map 主要用于那种映射的关系，例如一个人的姓名name(string)对应年龄age(short)。

```c++
map<string,name> people;
```

#### 5.容器之间各有优势。

![image-20210825170955664](https://gitee.com/ccnuktd/pic-bed/raw/master/img/202109071625283.png)

vector 的取下标运算容易，但是插入代价很大。（非常像我们平时使用的数组）

list 的插入删除开销不太大。（有点像链表结构）

map 的查找有优化。（可能就是用树实现的）

#### 6.基本的算法

##### 1.sort和copy

如果不想写排序，可以使用`sort`进行排序。

为了避免C语言有可能会出错的`realloc`我们可以使用`copy`函数。

```c++
void f(vector<int>a, vector<int>b){
	sort(a.begin(),a.end());
    //注意我们在copy的时候要考虑，b的空间能不能存放a的量
    //因此使用back_inserter()函数直接在b的末尾copy a的值，相当于realloc，但是更安全更好用
    copy(a.begin(),a.end(),back_inserter(b));
}
```

##### 2.find和count

find和count很像，我们一般都是利用find查找迭代器之间的值。

```c++
typedef string::const_iterator L1; 
L1 f(const string& s,char c){	//查找s中第一次出现c的位置（返回迭代器）
	L1 i = s.begin();
    while(i != s.end()){
		if(*i == c) return i;
        i ++;
    }
    return s.end();
}
//find用法
string m = "Mary had a little lamb";
string::iterator i = find(m.begin(),m.end(),'a');

//find还可以作为类的友元函数，此时就不需要位置了
string m = "Mary had a little lamb";
string::iterator i = m.find('a');
```

![image-20210825173122556](https://gitee.com/ccnuktd/pic-bed/raw/master/img/202109071624547.png)

```c++
//如果使用count
string m = "Mary had a little lamb";
int cnt = count(m.begin(),m.end(),'a');
//也可以对数组使用
int a[100] = {0};
int cnt = count(&a[0],&a[99],0);
```

#### 7.I/O输入输出与迭代器的关系

```c++
#include <iostream>
#include <string>
#include <vector>
#include <iterator>
using namespace std;
template<class T>class Vec:public vector<T>{
public:
    Vec():vector<T>(){}
    Vec(int s):vector<T>(s){}
    const T& operator[](int i)const { return this->at(i); }
    T& operator[](int i) { return this->at(i); }
};

int main(){
    ostream_iterator<string> oo(cout);
    istream_iterator<string> ii(cin);
    //istream_iterator<string> eos;
    *oo = "Hello ";
    ++ oo;
    oo = " world!\n"; 
    string s1 = *ii;
    ii ++;
    string s2 = *ii;
    cout << s1 << " " << s2 << endl; 
    return 0;
}   
```

这里直接给`oo`赋值，就相当于在终端中显示赋值的内容，把`ii`的值赋给变量相当于`cin`。

但是有一个问题：

>这段代码运行的时候，并没有一开始就输出Hello Word!，而是需要**先从终端中读入**然后才会输出“Hello World!”。
>
>难不成与`cin`，`cout`的优先级有关?
>
>
>
>猜测当运行到`istream_iterator<string> ii(cin)`的时候从检查输入，此时我们输入Hello+回车，ii的第一个元素就被刚才的输入赋值，当来到ii ++的时候，又进行上面的操作读入输入。

#### 8.用于控制算法的函数叫做谓词（谓词是bool类型的，如果是否大于42，0的数量是否为0个之类的）

![image-20210826142110530](C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20210826142110530.png)

![image-20210826151000916](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210826151000916.png)

