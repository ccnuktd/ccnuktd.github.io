# 10 类

### 10.2 类

#### 10.2.2 访问控制

在类中**公有和私有**的设计好处有两个方面：

>+ 便于排错
>  1. 如果类出现了非法情况，可以直接锁定问题出现在成员函数中，而不是公有界面中。
>  2. 非成员函数不能直接对类私有成员进行访问，这一层的错误在编译的时候就可以发现，而不需要通过运行来检查。
>+ 便于修改
>  1. 我们只需要通过修改成员函数，就可以解决错误。不需要再去修改公有界面以增加负担

**私有成员**也不完全**私有**

![image-20211101222113595](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211101222113595.png)

#### 10.2.3 构造函数

注意默认**构造函数**

#### 10.2.4 静态成员

* 什么时候时候需要使用静态成员？

>静态成员变量是**类**的一部分，但是它不是该类**对象**的一部分。
>
>同样，如果使用static函数，也是去访问类的一部分，但并需要访问特定的对象。

+ 如何操作静态成员？

>```c++
>class Date{
>private:
>    int d,m,y;
>    static Date default_date;
>public:
>    Date(int dd = 0,int mm = 0,int yy = 0){
>        d = dd;
>        m = mm;
>        y = yy;
>    }
>    // ···
>    static void set_default(int ,int ,int);
>    // ···
>};
>//下面关于类的静态成员的定义必须在**类外**
>
>//访问static成员需要加上类的域运算符
>void Date::set_default(int d,int m,int y){
>    Date::default_date = Date(d,m,y);
>}
>//设置default_date。设置为贝多芬的生日
>Date Date::default_date(16,12,1770);
>// 注意以上语句不能写成Date::default_date(16,12,1770);
>// 因为default_date是Date类型，定义的时候必须指明其类型
>
>```

#### 10.2.6 常量成员函数

注意点1：常量成员函数需要在后面跟一个const

```c++
inline int Date::year() const{
	year ++;
}
```

注意点2：非`const`对象**既可以调用`const`成员函数，也可以调用非`const`成员函数**；但是`const`对象只能调用**`const`成员函数**

```c++
int f(Date &a,const Date &b){
    //year函数是const函数，add_year是非const函数
	a.year();		//ok
    a.add_year();	//ok
    b.year();		//ok
    b.add_year();	//error
}
```

##### 10.2.7.1 物理和逻辑逻辑的常量性

可能会有这样一种情况，对象的`const`函数需要修改一个成员的值。换句话说，一个`const`函数在逻辑上是`const`形式，但是内部的操作（物理操作）可能并不完全符合`const`的原则。例如：

```c++
class HashTable {
 public:
    //...
    std::string lookup(const std::string& key) const
    {
        if (key == last_key_) {
            return last_value_;
        }

        std::string value{this->lookupInternal(key)};

        last_key_   = key;
        last_value_ = value;

        return value;
    }

 private:
    mutable std::string last_key_
    mutable std::string last_value_;
};
```

上面的代码是哈希表的实现。理论上来说，哈希表的查询函数不会修改值，逻辑上应该是`const`类型，但是这段代码中引入了**缓存技术**。代码通过`last_key_`和`last_value_`记录了上一次查询key-value对，如果本次查询与上一次相同，就可以直接输入，但是如果不相同，就需要修改`last_key_`和`last_value_`的值。

在这段代码中我们在`const`函数中修改了成员变量。

##### 10.2.7.2 可变的——mutable

那么为了解决这个问题我们引入了mutable这个关键字

![image-20211103145252207](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211103145252207.png)

#### 10.2.9 在类内部的函数定义

![image-20211103150010240](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211103150010240.png)

换句话说，类内部的定义的成员函数最好**小而且频繁使用**，这样有利于性能的提升。

##### 10.3 高效的用户定义类型

![image-20211103152011818](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211103152011818.png)

![image-20211103152028067](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211103152028067.png)

通过书上的这个例子，我们可以了解到设计一个类并不是一件容易的事情，简单的设计会带来操作的难度，复杂的设计会带来理解的难度。因此平衡非常重要。

### 10.3.2 协助函数

如果出现一批函数，他们和类有关系，但是又未必需要定义在类里面。

例如对于Date类，`int diff(Date a, Date b);//在范围[a,b)或者[b,a)中的天数`

对于种函数的处理，我们可以命名名字空间来分类管理

![image-20211105092802926](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105092802926.png)

### 10.3.4 具体类型的意义

上述像Date这样的简单用户定义类型被称之为**具体类型**，之所以这样叫是为了与**抽象类型**和**类层次结构**做区分，除此之外也为了说明这种类型与char,double的内部相似性。（我们不需要通过继承和派生来形成新的联系，这种类就像一个能操作的数据结构一般）

因为使用这种类型基本和char，double无异，对他们的使用称为**面向值的程序设计**，对这类类的设计与**面向对象程序设计**有很大**差异**。

> 心得：我所设计的很多类都是这种实现某功能而构造出来的**“数据结构”**，这其实不符合**OOP（object orient  programming）**的设计思想。

### 10.4.2 默认构造函数

![image-20211105094058995](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105094058995.png)

对于这个结构体的默认构造

>tt.t1和tt.vt都会调用Table类的构造函数
>
>而tt.i和tt.t1则不会被初始化，因为他们不是**类类型**的对象，只是普通类型，因此为了与C语言兼容，C++便没有对它们做任何处理

对于有一些一开始就必须要通过初始化才能构造的类型就**必须提供**构造函数，否则编译器会报错

例如下图：

![image-20211105094456752](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105094456752.png)

`const`和引用必须需要构造函数来构造。

#### 10.4.4.1 对象的复制

![image-20211105095611205](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105095611205.png)

>Table t2 = t1;//这里调用的是拷贝构造函数
>
>Table t3;
>
>t3 = t2;//这里调用的是赋值函数

```c++
class{
    Table(const Table&);
    Table& operator=(const Table&);
};

//之所以定义在类外，是因为这类函数使用较少没必要使用inline字段加快速度（类内加速）
Table(const Table&){
    ...
}

Table& operator=(const Table&){
    ...
    return *this;
}
```

### 10.4.6 类对象作为成员

当我们构造类的对象时，第一种思路是通过构造函数的参数，给成员变量赋值。

第二种思路是通过**成员构造函数**：

```c++
class Club{
	string name;
	Table members;
	Table officers;
	Date founded;
	
	Club(const string& s,Date fd)
};

Club::Club(const string& n,Date fd)
	:name(n),founded(fd);
{
	...
}
```

**注意：**成员的构造函数会按照**类声明成员的顺序**来构造成员，**而不是通过成员构造函数的顺序**。

这两种策略谁好谁坏呢？一般来说没有好坏，但是通常使用成员构造函数的可能会带来效率的提升

![image-20211105101851938](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105101851938.png)

上图种的address先被空串初始化（string类型的默认初始化），然后被a赋值。

与其这样不如直接用a初始化address。

#### 10.4.6.2 成员常量

如果我们要实现在类中使用常量通常是这样做的：

```c++
class A{
  public:
    static const int a = 13;
    //不能写成以下形式
    static int b = 13;
    const int c = 13;
    static const int d = f(13);//不是常量
    static const float e = 7.9;//必须赋值**常量**，而且必须用**整形**
};
```

或者用枚举

![image-20211105103212776](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105103212776.png)

### 10.4.7 数组

注意new和delete关于数组的操作

![image-20211105103613205](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211105103613205.png)

### 10.4.10 临时对象

一个临时对象除非被约束到某个引用，或者被用于对象的初始化，否则它总在**建立它的那个完整表达式结束时被销毁**。

所以应该尽量避免这样的代码

```c++
f(string &c1,string &c2){
	const char * cc = (c1 + c2).c_str();
    //c1 + c2这个临时对象在创建完成后，就已经被销毁
    //这个指针就是一个野指针（非常不安全）
}
```

#### 小衷告

![image-20211106093547083](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211106093547083.png)

