# 预算符重载

### 11.1 引言

`a + b`等价于`a.operator + (b)`

因此对于成员函数的重载会少一个参数（参与运算的左边的值a，已经通过调用运算符重载函数`opeartor +`给出）

#### 11.2.1 二元和一元运算符

![image-20211106105247572](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211106105247572.png)

#### 11.2.4 名字空间里的运算符

![image-20211106110106943](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211106110106943.png)

分析：编译器在执行`std::cout << p >> "," << s << "!\n";`这一句话的时候做了什么呢？

这张图说明了编译器的寻找方式：

![image-20211106110300611](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211106110300611.png)

具体解释：

>`cout << p`等价于`cout.operator << (p)`
>
>编译器先是去找一下`cout`的类`ostream`以及它的**基类**的成员函数
>
>再上图中编译器找到了`ostream& operator << (const char *);`这个成员函数，但是这个成员函数不符合传参的类型
>
>编译器再去找满足`operator << (cout,p);`的函数，于是找到了这个函数
>
>`ostream& operator<<(ostream&, const string&);`
>
>所以这个函数被执行
>
>补充一句：p是一个类，那么编译器也会寻找p的成员函数以及定义p的名字空间中寻找最合适的函数

### 成员运算符和非成员运算符

有这样一种设计思想，在运算符重载的时候，尽量去复用函数

比如说：要实现 

![image-20211106111747950](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211106111747950.png)

>我们可以在成员函数中只重载 += 这个运算符
>
>```c++
>inline complex& operator +=(complex){
>	this->re += a.re;
>this->im += a.im;
>return *this;
>}
>```
>
>在别的地方重载 +  等函数调用+=成员函数
>
>```c++
>complex opeartor +(complex a,complex b){
>complex r = a;
>return r += b;
>}
>```
>
>当然我们不可能只重载+=成员函数就可以解决问题，但是这种**在类内只重载最少函数的思路**是可以去学习的。（这是一种代码复用的思路）
>
>除了这种思路以外，我们也可以减低这些函数的耦合度。即，在类中重载出所有需要的运算符，它们之间没有关系。

#### 11.3.4 复制

Tip：

```c++
complex(double im,double re):im(im),re(re){}
complex(double im,double re){
	this->im = im;
    this->re = re;
}
//第一种方法比第二种清晰一些
```

进行类的拷贝复制的时候，千万不要写出这样的代码

```c++
complex(complex c):re(c.re),im(c.im){}
```

因为这样会陷入无限递归(不过编译器也不准你这样写)

```
//正常的做法是
complex(const complex &c):re(c.re),im(c.im){}
```

拷贝构造函数和普通的初始化的区别

![image-20211107094234128](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211107094234128.png)

上面的代码是拷贝构造函数，执行需要两步

1. 先构造
2. 再初始化

而不同的初始化只有一步

因此这个地方可以做优化

#### 转换运算符

基本的类型转换不能运用在**类和基本类型**，**类和类**的转换上。因此需要引入转换运算符。

![image-20211107141504553](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211107141504553.png)

`operator int() const{return v};`就是一个类型转换函数，把Tiny类型（类）转化为int类型

还有一个更为熟悉的例子：

`while(cin >> a);` `cin >> a`返回的是一个ostream&，这里直接把ostream& 对象转化为了bool基本类型

### 11.5 友元

友元**不会**给外围的作用域引入名字，换句话说友元定义必须和类在同一个作用域内

![image](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211107143629690.png)

在上图中友元的声明和定义不在同一个作用域内，那么complex类就无法使用<<友元函数

成员和友元的选择问题查看书本 P 251(wps为280)

还有一些存储技巧**不太看得懂** P 253(wps为281)

C++的声明陷阱

[博客](https://blog.csdn.net/u011529752/article/details/60780464?utm_term=c++%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E5%90%8E%E9%9D%A2%E5%8A%A0%E6%8B%AC%E5%8F%B7&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-60780464&spm=3001.4430)

```c++
int main(){
    String a();//不会调用无参构造函数，这里实际上是**声明一个无参数的函数**
	String a;//调用默认构造函数
    String a(1,2);//调用符合参数的构造函数
    
    String *a = new String();
    //这个可以和String a()做对比，这个是从堆空间申请String大小的内存，然后调用无参构造函数
    String *a = new String;
    //这个和String *a = new String();一样
    String *a = new String(1,2);
    //这个和上面两个的区别在于调用的构造函数不同
    
    int a(1);//给int初始化了
    int a;//没给int初始化
    int *a = new int(1);//给指针初始化了1（不过这个地址是无效的地址）
    int *a = new int;//没有给指针初始化
}
```

#### 11.7.1 显示构造函数

explicit关键字可以避免隐式转换

```c++
class Test1{
    int a;
public:
    Test1(int a):a(a){}
};
class Test2{
    int a;
public:
    explicit Test2(int a):a(a){}
};
int main(){
    Test1 a = 12; // pass
    Test2 b = 12; // error，不允许int到Test2的隐式转换
    Test2 c = Test2(12); // pass
	return 0;
}
```

引入explicit的目的，我认为是避免一些特殊的转换，因为这些转换可能导致错误，如果一开始就规定了explicit就不会引入这种错误。

###11.8 下标

下标运算符号的重载有一点点技巧，一般进行运算符重载会重载两个函数

```c++
//第一个函数在不修改下标值情况下调用cout << ss[1];
const int& operator[](const string a);
//第二个函数在修改下标值的情况下调用ss[2] = (string)"1sdfsdf";
int& operator[](string a);
```

一开始我有一个疑惑，这两个函数的参数非常相似，编译器如何判断我要调用的是哪一个函数呢？
猜想一：根据内容判断

经过测试，即使两个函数的内容写成一样，编译器也能正确调用，因此编译器不是通过内容判断的。

猜想二：根据返回值辅助判断

虽然说对函数的重载如果仅仅是**返回值不同**，是不能区别两个函数的。但是如果修改了返回值，那么肯定返回`const int&`的调用就不会成功，因此会调用返回`int &`的；如果不修改，那么`const int&`的函数匹配的更好，应该优先调用。

### 11.9 函数调用

使用for_each实现反复调用**P286**，暂时不太理解后面再补

###11.10 间接 

++和--的前后缀重载

```c++
class integer(){
	int i;
public:
    integer(int i = 0):i(){}
    //前缀++要返回引用
    //调用是：p.opeartor++();
    integer& operator ++(){
        this->i ++;
        return *this;
    }
    //后缀++不能返回引用
    //调用是：p.opeartor++(0);
    integer operator ++(int i){
		integer temp = *this;
        this->i ++;
        return temp;
    }
    //前缀--要返回引用
    integer& operator --(){
        this->i --;
        return *this;
    }
    //后缀--不能返回引用
    integer operator --(int i){
		integer temp = *this;
        this->i --;
        return temp;
    }
};
```

之所以需要进入`int i`纯属是为了区分前缀和后缀，`i`是虚设的。
