# 程序设计思想

### 1.过程式程序设计

思想：确定你需要的那些过程，采用你能找到的最好的算法。

### 2.模块化程序设计

思想：确定你需要那些模块，将程序分为一些模块，使数据隐藏在模块当中。

#### 总结一下C++的设计思想（与C语言或者别的语言的区别）

##### 1.分别编译

在C语言中，由于我们一般处理的是面向过程的编程问题，我们没有必要**去对程序分别编译**，但是许多问题其实可以共用一些基本的界面，例如

![image-20210825144730041](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825144730041.png)

**注：**并不是只能include `.h`的头文件，也可以include `.cpp`文件，注意include 做的是代码片段的插入，因此如果一个`.cpp`文件中的代码可以插入到另一个`.cpp`文件中（前者没有main 函数），这个操作也是可行的。

##### 2.异常处理

![image-20210825150214674](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825150214674.png)

##### 3.定义类型的模块

基于模块的程序设计，以一个类型的所有数据为中心，并使用某个控制管理模块进行控制，假如我们需要有**多个堆栈，而且为这些堆栈配置控制器**。

![image-20210825150745489](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825150745489.png)

![image-20210825150914164](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825150914164.png)

##### 4.用户定义类型（类的定义）

###### 1.具体类型：

上面的这种这种方法的缺点就是**封装**的问题，例如堆栈Rep应该只能由掌控堆栈的Stack::create() 和Stack::destroy() 两个函数掌控，而不能被普遍的语言控制。

因此我我们引入用户定义类型，即，类

![image-20210825151319311](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825151319311.png)

![image-20210825151334318](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825151334318.png)

我们可以一次性清晰的表示一种想要表达的十五，也可以通过**权限的访问（public，protected和private）**来达到控制的目的

###### 2.抽象类型

我们回想一下具体类型的缺陷，如果我们有多个stack（double_stack,char_stack,int_stack）我们在访问接口的时候，就应该调用多个类型的push和pop操作。

![image-20210825152106612](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825152106612.png)

那么我们有没有方法用一个函数f就解决问题呢？其实是可以的，那就是使用抽象数据类型（ADT）。

![image-20210825152317796](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825152317796.png)

![image-20210825152327226](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825152327226.png)

我们的这些double_stack,int_stack就可以通过继承虚基类，这样即实现了**界面和内容的分离**，也达成了**一个函数可以供多种stack的使用**。这种类型叫做**多态类型**。

但是问题在于我们怎么知道传入的参数是哪一个stack（是double的，还是int的，还是char的），这个时候就要用到**虚函数**了。

![image-20210825153432115](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825153432115.png)

##### 5.通用型程序设计

![image-20210825153625375](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825153625375.png)

![image-20210825153655251](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825153655251.png)

这样我们就可以定义出很多种类型的stack了！

![image-20210825153722866](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825153722866.png)

##### 6.通用型算法

我们是不是也可以去写一些针对所有类型的算法呢？

![image-20210825153847778](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825153847778.png)

![image-20210825154200575](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825154200575.png)

![image-20210825154246185](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825154246185.png)

![image-20210825154313906](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20210825154313906.png)