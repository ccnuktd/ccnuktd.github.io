# 13.2 一个简单的String模板

简单来说，只需要在类型面前加上`template <class T>`

这里的T指的**并不是类名**，而是更广阔的范围——类型名

类型名除了包括类名，还包括基本类型`int`，`char`，也包括`typedef`引入的名字

小例子：

>在标准库中定义了一个模板类`basic_string`，而我们常用的`string`其实是`basic_string<char>`
>
>之所以可以用`string`来定义，是因为使用了`typedef`隐藏了`basic_string`
>
>```c++
>typedef basic_string<char> string;
>```
>
>因为用户不关心`string`到底用了什么模板，所以这个技巧可以用来<font color="red">细节和复杂性</font>

### 13.2.1 定义一个类模板

在书本的这一节中发现了一个错误的例子

```c++
//下面的这个构造函数无法过编译
template<class C>String<C>::String<C>(){
    ;
}

//但是这样写就可以过编译
template<class C>String<C>::String(){
    ;
}
```

不可以过编译![image-20211122193313219](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211122193313219.png)

可以过编译

![image-20211122193354974](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211122193354974.png)

由于类模板的定义有一定的复杂性，这里给出一个总结的例子

```c++
template<class C>class String{
public:
    //类模板的嵌套，注意底下的T不能和C重名
    template<class T>struct temp{
      	int a,b;
        //模板类内部的构造函数
        temp():a(0),b(0) { } 
    };
    temp<C>* p;
    String();
};
//模板类外面的构造函数，比较复杂
template<class C>String<C>::String(){
    ;
}
```

### 13.2.2 模板实例化

```c++
String<char> cs;
void f(){
	String<Jchar> js;
	cs = "adsfsdf";
}
```

执行上面的代码，编译器干了什么事情呢？

>编译器会生成`String<char>`和`String<Jchar>`的声明，与他们对应的`Srep(String内部实现的一个类)`类，以及他们的默认构造函数和析构函数，还有`String<char>`的赋值函数
>
>想想看，如果写一个类模板，编译器把所有可能类型的各种函数都生成出来，那么存储的消耗就太大了

### 13.2.3 模板参数

注意

```c++
template<class T,int i> class String{
    ···
};
//int i只能传入常量表达式
String<char,i> s1;	//错误
String<char,1> s2;	//正确
```



