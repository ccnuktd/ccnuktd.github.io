(\*表示什么都不参考能做出来，\*\*表示需要相关知识点不熟，\*\*\*表示相关代码使用不熟，\*\*\*\*表示写了很久才想出来[不一定对]，#表示做不出来，##表示做出来后第二次还是做不出来，###表示看了答案也做不出来)

| 题目名称  | 算法类型               | 做题情况 |
| --------- | ---------------------- | -------- |
| **NC93**  | LRU替换算法            | \*\*\*\* |
| **NC76**  | 模拟                   | \*       |
| **NC15**  | 树的层次遍历           | *        |
| **NC41**  | 最长无重复子数组       | \*\*\*\* |
| **NC102** | 两个节点的最近公共祖先 | \*\*     |
| **NC119** | 最小的第k个数          | \*       |
| **NC19**  | 连续子序列的最大和     | \*       |
| **NC137** | 表达式求值             | **       |
|           |                        |          |

### NC93

#### 设计思路

哈希表+双向链表

哈希表的value存储的是**双向链表的地址**，如下图：

![image-20211102170327365](https://gitee.com/ccnuktd/pic-bed/raw/master/image-20211102170327365.png)

想实现存取都为O(1)，我们使用了哈希表，因为哈希表的存取都是O(1)，但是我们还需要一个结构来记录**最近最少使用**的值。因此我们想到可以通过**链表的顺序**来模拟**使用**的情况。（可以设计成：使用的结点直接移动到链表的尾部，越是经常用越是在尾部，如果结构已满，就移除首节点）

### 易错点

1. 在这个双向链表中，需要记录`val`。如果不记录`val`，那么删除首结点时，无法通过`value`找到哈希表的`key`，这样就无法清除哈希表`key`对应的的`Linknode*`，此时的`Linknode*`是一个野指针。但如果记录了`val`就可以把哈希表`key`对应的`Linknode*`置为`NULL`，这样就不会有野指针的问题了。
2. 进行链表结点移动的时候，需要考虑结点是位于**头部、尾部还是中间**，不考虑肯定会有问题。

### NC76

注意用两个栈模拟队列的时候，**输出栈**必须清空以后才能允许**输入栈的值进入输出栈**。

而不是每一次用pop的时候，都把输入栈的值放入输出栈。

### NC15 

注意判断**根节点是否为空**！

### NC14

这个题有两个要注意的点：

1. 我们使用双指针（一个指针A为遍历的数组最右端，一个指针B指向未重复序列的最左端），通过维护这两个指针，来得到最大值。所以每一次指针**A右移的时候都需要更新最大值**。
2. 当发现有重复值的时候，需要比较重复值所在位置与B指针的位置，如果B指针在后面，即使发生重复也不需要考虑（因为B指针之前可能以及发生别的重复，如果把B指针回退有可能出问题），只有B指针在重复位置前，才需要更新B指针的位置。

### NC102

这个题要注意有可能出现`root->val`就等于o1或者o2的情况，要注意o1和o2可能出现一个是另一个的祖先这种情况。

### NC119

写归并排序的时候要注意

```c++
//split函数：写法一
if(left < right){
    int mid = left + (right - left) / 2;
    split(left,mid);
    split(mid + 1,right);
    merge(left,right);
}
//split函数：写法二
if(left < right){
    int mid = left + (right - left) / 2;
    split(left,mid - 1);
    split(mid,right);
    merge(left,right);
}
```

写法一是正确写法，写法二会导致无限递归。

因为在`int mid = left + (right - left) / 2;`这句话中，mid本身是向下取整的，`split(mid,right);`会一直停留在left比right小1的情况下，这样就出现了无限的递归。

### NC19

这道题有一种非常简单的思路

```c++
int f(vector<int> array) {
    int max = array[0],now = array[0];
    for(int i = 1;i < array.size();i ++){
        now = now + array[i] > array[i] ? now + array[i] : array[i];//求包括第i个元素的子序列最大值
        max = max > now ? max : now;//更新子序列最大值
    }
    return max;
}
```

max为子序列的最大和（计算到当前`i`位置），now为包含第`i`个元素的子序列最大和。

前`i`个子序列的最大和 = max(前`i-1`个子序列的最大和 + 第`i`个元素的值, 第`i`个元素的值)

### NC137

要记得表达式求值【只有+-*/和()】的算法

>1. 遇到左括号直接压栈
>2. 遇到右括号弹栈直到遇到左括号为止
>3. 当前符号优先级**高于**栈顶元素才能压栈
