### 汇编语言程序设计

#### 1.段定义伪指令

`SEGMENT`一个逻辑段定义开始的标志

**定义语法** 

```assembly
段名 SEGMENT {定义类型}{组合类型}{类别}
···
段名 ENDS
```

**举例**

```assembly
STACK SEGMENT
···
STACK ENDS
```

**定位类型**

PAGE（页）型 （浪费空间）

PARA（节）型 （默认类型）

WORD（字）型 X（不常用）

BYTE（字节）型 X （不常用）

**组合类型**

STACK

```assembly
STACK SEGMENT STACK DB 256 DUP(?) 
ENDS STACK
;告诉link.exe这一段就是stack段
```

NONE

表明该段不与任何段构成联系

#### 2. 8086汇编语言程序的完整结构

```assembly
;堆栈段
STACK SEGMENT STACK DB 256 DUP(?) 
TOP LABEL  WORD	;不占空间的指明
ENDS STACK
;数据段
DATA SEGMENT
···
DATA ENDS
;代码段
CODE SEGMENT
;在这里你得告诉CS,SS等段寄存器，你的程序在哪里（有一些极端情况比如说在STACK段写程序之类的）
;这个时候就必须用到ASSUME（段寻址伪指令）,这样将段名和自己写的段构成联系
ASSUME CS:CODE,DS:DATA,SS:STACK
ASSUME ES:DATA
;但是ASSUME并没有做事（伪指令都不做事）,因此你得自己给段寄存器初始化
;这个START主要是用来初始化CS和IP，和上面的ASSUME对应
START:MOV AX, DATA;由于DATA不是一个变量，自身本身具有段地址属性，这个地方的寻址为立即数寻址
MOV DX, AX
MOV EX, AX
;千万别写这种
MOV AX, CODE
MOV CS, AX
;CS不能做目的
;下面三句汇编器自己做了
MOV AX, STACK
MOV SS, AX
MOV SP, OFFSET TOP
;在结束之前需要返回DOS操作系统
MOV AH, 4CH
INT 21H
CODE ENDS
;END伪指令,汇编结束伪指令,后面需要接一个起始的段，目的是用于初始化CS和IP
END START
```

#### 3.一些例子

3.1.求15个字节的数的校验和，并把校验和存到第16个字节的位置上去

补充说明：

> 在进行数据校验的时候，不只是靠**奇偶校验**，还可以靠**和校验**
>
> 和校验是指：接受方和发送方对发送的数据求和（不考虑进位），校验最后的结果
>
> 通过**二次校验**，提高了可靠性

```assembly
;没有堆栈段
DATA SEGMENT
BUFFER DB 11H,24H,···,56H
	DB ?	;第16号单元
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:
    MOV AL,DATA
    MOV	DS,AL
	LEA SI,BUFFER
	MOV CX,15
	XOR AL,AL	
L1:	ADD AL,[SI]	;AL清零
	INC SI
	LOOP L1
	mov [SI],AL
	MOV AH,4CH
	INT 21H
CODE ENDS
	END START
```

